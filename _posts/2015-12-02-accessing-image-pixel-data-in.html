---
title: Accessing Image Pixel Data in a Xamarin.Forms App – iOS
date: '2015-12-02T16:13:00.000Z'
author: David Britch
tags:
- C#
- Xamarin
- pixel data
modified_time: '2015-12-02T16:14:17.440Z'
blogger_id: tag:blogger.com,1999:blog-8265682915956744370.post-8290839412072045134
blogger_orig_url: https://dbritch.blogspot.com/2015/12/accessing-image-pixel-data-in.html
---

<p><a href="http://www.davidbritch.com/2015/11/accessing-image-pixel-data-in.html">Previously</a>, I’ve described a basic architecture for accessing and manipulating pixel data from a Xamarin.Forms project. A Xamarin.Forms PCL project defines the <strong>IBitmap</strong> interface, which specifies the operations that must be implemented in each platform-specific project to access and manipulate pixel data. </p> <p>In this blog post I’ll explain the operation of the <strong>Bitmap</strong> class in the Xamarin.Forms iOS project, which implements the <strong>IBitmap</strong> interface. The <a href="https://developer.xamarin.com/guides/cross-platform/xamarin-forms/dependency-service/">DependencyService</a> can be used to invoke a method from the Xamarin.Forms PCL project, which in turn invokes <strong>IBitmap</strong> operations.</p> <p><strong>Disclaimer:</strong> The code featured here is alpha code, so all the usual caveats apply.</p> <h3>Implementation</h3> <p>The following code shows the <strong>Bitmap</strong> class implementation on iOS:</p> <div id="scid:9D7513F9-C04C-4721-824A-2B34F0212519:eb2f17e9-cc96-42b5-bc40-ba961a1cd9cd" class="wlWriterEditableSmartContent" style="float: none; padding-bottom: 0px; padding-top: 0px; padding-left: 0px; margin: 0px; display: inline; padding-right: 0px"><pre style=" width: 814px; height: 1240px;background-color:White;overflow: hidden;"><div><!--<br /><br />Code highlighting produced by Actipro CodeHighlighter (freeware)<br />http://www.CodeHighlighter.com/<br /><br />--><span style="color: #008080;"> 1</span> <span style="color: #000000;">    </span><span style="color: #0000FF;">public</span><span style="color: #000000;"> </span><span style="color: #0000FF;">class</span><span style="color: #000000;"> Bitmap : IBitmap</span><span style="color: #000000;">&lt;</span><span style="color: #000000;">UIImage</span><span style="color: #000000;">&gt;</span><span style="color: #000000;"><br /></span><span style="color: #008080;"> 2</span> <span style="color: #000000;">    {<br /></span><span style="color: #008080;"> 3</span> <span style="color: #000000;">        </span><span style="color: #0000FF;">const</span><span style="color: #000000;"> </span><span style="color: #0000FF;">byte</span><span style="color: #000000;"> bitsPerComponent </span><span style="color: #000000;">=</span><span style="color: #000000;"> </span><span style="color: #800080;">8</span><span style="color: #000000;">;<br /></span><span style="color: #008080;"> 4</span> <span style="color: #000000;">        </span><span style="color: #0000FF;">const</span><span style="color: #000000;"> </span><span style="color: #0000FF;">byte</span><span style="color: #000000;"> bytesPerPixel </span><span style="color: #000000;">=</span><span style="color: #000000;"> </span><span style="color: #800080;">4</span><span style="color: #000000;">;<br /></span><span style="color: #008080;"> 5</span> <span style="color: #000000;">        UIImage image;<br /></span><span style="color: #008080;"> 6</span> <span style="color: #000000;">        </span><span style="color: #0000FF;">readonly</span><span style="color: #000000;"> </span><span style="color: #0000FF;">int</span><span style="color: #000000;"> width;<br /></span><span style="color: #008080;"> 7</span> <span style="color: #000000;">        </span><span style="color: #0000FF;">readonly</span><span style="color: #000000;"> </span><span style="color: #0000FF;">int</span><span style="color: #000000;"> height;<br /></span><span style="color: #008080;"> 8</span> <span style="color: #000000;">        IntPtr rawData;<br /></span><span style="color: #008080;"> 9</span> <span style="color: #000000;">        </span><span style="color: #0000FF;">byte</span><span style="color: #000000;">[] pixelData;<br /></span><span style="color: #008080;">10</span> <span style="color: #000000;">        UIImageOrientation orientation;<br /></span><span style="color: #008080;">11</span> <span style="color: #000000;"><br /></span><span style="color: #008080;">12</span> <span style="color: #000000;">        </span><span style="color: #0000FF;">public</span><span style="color: #000000;"> Bitmap (UIImage uiImage)<br /></span><span style="color: #008080;">13</span> <span style="color: #000000;">        {<br /></span><span style="color: #008080;">14</span> <span style="color: #000000;">            image </span><span style="color: #000000;">=</span><span style="color: #000000;"> uiImage;<br /></span><span style="color: #008080;">15</span> <span style="color: #000000;">            orientation </span><span style="color: #000000;">=</span><span style="color: #000000;"> image.Orientation;<br /></span><span style="color: #008080;">16</span> <span style="color: #000000;">            width </span><span style="color: #000000;">=</span><span style="color: #000000;"> (</span><span style="color: #0000FF;">int</span><span style="color: #000000;">)image.CGImage.Width;<br /></span><span style="color: #008080;">17</span> <span style="color: #000000;">            height </span><span style="color: #000000;">=</span><span style="color: #000000;"> (</span><span style="color: #0000FF;">int</span><span style="color: #000000;">)image.CGImage.Height;<br /></span><span style="color: #008080;">18</span> <span style="color: #000000;">        }<br /></span><span style="color: #008080;">19</span> <span style="color: #000000;"><br /></span><span style="color: #008080;">20</span> <span style="color: #000000;">        </span><span style="color: #0000FF;">public</span><span style="color: #000000;"> </span><span style="color: #0000FF;">void</span><span style="color: #000000;"> ToPixelArray ()<br /></span><span style="color: #008080;">21</span> <span style="color: #000000;">        {<br /></span><span style="color: #008080;">22</span> <span style="color: #000000;">            </span><span style="color: #0000FF;">using</span><span style="color: #000000;"> (var colourSpace </span><span style="color: #000000;">=</span><span style="color: #000000;"> CGColorSpace.CreateDeviceRGB ()) {<br /></span><span style="color: #008080;">23</span> <span style="color: #000000;">                rawData </span><span style="color: #000000;">=</span><span style="color: #000000;"> Marshal.AllocHGlobal (width </span><span style="color: #000000;">*</span><span style="color: #000000;"> height </span><span style="color: #000000;">*</span><span style="color: #000000;"> </span><span style="color: #800080;">4</span><span style="color: #000000;">);<br /></span><span style="color: #008080;">24</span> <span style="color: #000000;">                </span><span style="color: #0000FF;">using</span><span style="color: #000000;"> (var context </span><span style="color: #000000;">=</span><span style="color: #000000;"> </span><span style="color: #0000FF;">new</span><span style="color: #000000;"> CGBitmapContext (rawData, width, height, bitsPerComponent, bytesPerPixel </span><span style="color: #000000;">*</span><span style="color: #000000;"> width, colourSpace, CGImageAlphaInfo.PremultipliedLast)) {<br /></span><span style="color: #008080;">25</span> <span style="color: #000000;">                    context.DrawImage (</span><span style="color: #0000FF;">new</span><span style="color: #000000;"> CGRect (</span><span style="color: #800080;">0</span><span style="color: #000000;">, </span><span style="color: #800080;">0</span><span style="color: #000000;">, width, height), image.CGImage);<br /></span><span style="color: #008080;">26</span> <span style="color: #000000;">                    pixelData </span><span style="color: #000000;">=</span><span style="color: #000000;"> </span><span style="color: #0000FF;">new</span><span style="color: #000000;"> </span><span style="color: #0000FF;">byte</span><span style="color: #000000;">[width </span><span style="color: #000000;">*</span><span style="color: #000000;"> height </span><span style="color: #000000;">*</span><span style="color: #000000;"> bytesPerPixel];<br /></span><span style="color: #008080;">27</span> <span style="color: #000000;">                    Marshal.Copy (rawData, pixelData, </span><span style="color: #800080;">0</span><span style="color: #000000;">, pixelData.Length);<br /></span><span style="color: #008080;">28</span> <span style="color: #000000;">                    Marshal.FreeHGlobal (rawData);<br /></span><span style="color: #008080;">29</span> <span style="color: #000000;">                }<br /></span><span style="color: #008080;">30</span> <span style="color: #000000;">            }<br /></span><span style="color: #008080;">31</span> <span style="color: #000000;">        }<br /></span><span style="color: #008080;">32</span> <span style="color: #000000;"><br /></span><span style="color: #008080;">33</span> <span style="color: #000000;">        </span><span style="color: #0000FF;">public</span><span style="color: #000000;"> </span><span style="color: #0000FF;">void</span><span style="color: #000000;"> TransformImage (Func</span><span style="color: #000000;">&lt;</span><span style="color: #0000FF;">byte</span><span style="color: #000000;">, </span><span style="color: #0000FF;">byte</span><span style="color: #000000;">, </span><span style="color: #0000FF;">byte</span><span style="color: #000000;">, </span><span style="color: #0000FF;">double</span><span style="color: #000000;">&gt;</span><span style="color: #000000;"> pixelOperation)<br /></span><span style="color: #008080;">34</span> <span style="color: #000000;">        {<br /></span><span style="color: #008080;">35</span> <span style="color: #000000;">            </span><span style="color: #0000FF;">byte</span><span style="color: #000000;"> r, g, b;<br /></span><span style="color: #008080;">36</span> <span style="color: #000000;"><br /></span><span style="color: #008080;">37</span> <span style="color: #000000;">            </span><span style="color: #008000;">//</span><span style="color: #008000;"> Pixel data order is RGBA</span><span style="color: #008000;"><br /></span><span style="color: #008080;">38</span> <span style="color: #008000;"></span><span style="color: #000000;">            </span><span style="color: #0000FF;">try</span><span style="color: #000000;"> {<br /></span><span style="color: #008080;">39</span> <span style="color: #000000;">                </span><span style="color: #0000FF;">for</span><span style="color: #000000;"> (</span><span style="color: #0000FF;">int</span><span style="color: #000000;"> i </span><span style="color: #000000;">=</span><span style="color: #000000;"> </span><span style="color: #800080;">0</span><span style="color: #000000;">; i </span><span style="color: #000000;">&lt;</span><span style="color: #000000;"> pixelData.Length; i </span><span style="color: #000000;">+=</span><span style="color: #000000;"> bytesPerPixel) {<br /></span><span style="color: #008080;">40</span> <span style="color: #000000;">                    r </span><span style="color: #000000;">=</span><span style="color: #000000;"> pixelData [i];<br /></span><span style="color: #008080;">41</span> <span style="color: #000000;">                    g </span><span style="color: #000000;">=</span><span style="color: #000000;"> pixelData [i </span><span style="color: #000000;">+</span><span style="color: #000000;"> </span><span style="color: #800080;">1</span><span style="color: #000000;">];<br /></span><span style="color: #008080;">42</span> <span style="color: #000000;">                    b </span><span style="color: #000000;">=</span><span style="color: #000000;"> pixelData [i </span><span style="color: #000000;">+</span><span style="color: #000000;"> </span><span style="color: #800080;">2</span><span style="color: #000000;">];<br /></span><span style="color: #008080;">43</span> <span style="color: #000000;"><br /></span><span style="color: #008080;">44</span> <span style="color: #000000;">                    </span><span style="color: #008000;">//</span><span style="color: #008000;"> Leave alpha value intact</span><span style="color: #008000;"><br /></span><span style="color: #008080;">45</span> <span style="color: #008000;"></span><span style="color: #000000;">                    pixelData [i] </span><span style="color: #000000;">=</span><span style="color: #000000;"> pixelData [i </span><span style="color: #000000;">+</span><span style="color: #000000;"> </span><span style="color: #800080;">1</span><span style="color: #000000;">] </span><span style="color: #000000;">=</span><span style="color: #000000;"> pixelData [i </span><span style="color: #000000;">+</span><span style="color: #000000;"> </span><span style="color: #800080;">2</span><span style="color: #000000;">] </span><span style="color: #000000;">=</span><span style="color: #000000;"> (</span><span style="color: #0000FF;">byte</span><span style="color: #000000;">)pixelOperation (r, g, b);<br /></span><span style="color: #008080;">46</span> <span style="color: #000000;">                }<br /></span><span style="color: #008080;">47</span> <span style="color: #000000;">            } </span><span style="color: #0000FF;">catch</span><span style="color: #000000;"> (Exception ex) {<br /></span><span style="color: #008080;">48</span> <span style="color: #000000;">                Console.WriteLine (ex.Message);<br /></span><span style="color: #008080;">49</span> <span style="color: #000000;">            }<br /></span><span style="color: #008080;">50</span> <span style="color: #000000;">        }<br /></span><span style="color: #008080;">51</span> <span style="color: #000000;"><br /></span><span style="color: #008080;">52</span> <span style="color: #000000;">        </span><span style="color: #0000FF;">public</span><span style="color: #000000;"> UIImage ToImage ()<br /></span><span style="color: #008080;">53</span> <span style="color: #000000;">        {<br /></span><span style="color: #008080;">54</span> <span style="color: #000000;">            </span><span style="color: #0000FF;">using</span><span style="color: #000000;"> (var dataProvider </span><span style="color: #000000;">=</span><span style="color: #000000;"> </span><span style="color: #0000FF;">new</span><span style="color: #000000;"> CGDataProvider (pixelData, </span><span style="color: #800080;">0</span><span style="color: #000000;">, pixelData.Length)) {<br /></span><span style="color: #008080;">55</span> <span style="color: #000000;">                </span><span style="color: #0000FF;">using</span><span style="color: #000000;"> (var colourSpace </span><span style="color: #000000;">=</span><span style="color: #000000;"> CGColorSpace.CreateDeviceRGB ()) {<br /></span><span style="color: #008080;">56</span> <span style="color: #000000;">                    </span><span style="color: #0000FF;">using</span><span style="color: #000000;"> (var cgImage </span><span style="color: #000000;">=</span><span style="color: #000000;"> </span><span style="color: #0000FF;">new</span><span style="color: #000000;"> CGImage (width, height, bitsPerComponent, bitsPerComponent </span><span style="color: #000000;">*</span><span style="color: #000000;"> bytesPerPixel, bytesPerPixel </span><span style="color: #000000;">*</span><span style="color: #000000;"> width, colourSpace, CGBitmapFlags.ByteOrderDefault, dataProvider, </span><span style="color: #0000FF;">null</span><span style="color: #000000;">, </span><span style="color: #0000FF;">false</span><span style="color: #000000;">, CGColorRenderingIntent.Default)) {<br /></span><span style="color: #008080;">57</span> <span style="color: #000000;">                        image.Dispose ();<br /></span><span style="color: #008080;">58</span> <span style="color: #000000;">                        image </span><span style="color: #000000;">=</span><span style="color: #000000;"> </span><span style="color: #0000FF;">null</span><span style="color: #000000;">;<br /></span><span style="color: #008080;">59</span> <span style="color: #000000;">                        pixelData </span><span style="color: #000000;">=</span><span style="color: #000000;"> </span><span style="color: #0000FF;">null</span><span style="color: #000000;">;<br /></span><span style="color: #008080;">60</span> <span style="color: #000000;">                        </span><span style="color: #0000FF;">return</span><span style="color: #000000;"> UIImage.FromImage (cgImage, </span><span style="color: #800080;">0</span><span style="color: #000000;">, orientation);<br /></span><span style="color: #008080;">61</span> <span style="color: #000000;">                    }<br /></span><span style="color: #008080;">62</span> <span style="color: #000000;">                }<br /></span><span style="color: #008080;">63</span> <span style="color: #000000;">            }<br /></span><span style="color: #008080;">64</span> <span style="color: #000000;">        }<br /></span><span style="color: #008080;">65</span> <span style="color: #000000;">    }</span></div></pre><!-- Code inserted with Steve Dunn's Windows Live Writer Code Formatter Plugin.  http://dunnhq.com --></div><p>The<strong> ToPixelArray</strong> method is used to convert the <strong>UIImage</strong> to a byte array of raw pixel data. The image’s pixel data is placed into unmanaged memory through the <strong>DrawImage</strong> method, and is referenced through the <strong>rawData IntPtr</strong>. It’s formatted as 32 bits per pixel, with each pixel being composed of a Red, Green, Blue, and Alpha channel. It’s then copied to the managed <strong>pixelData</strong> array, before the unmanaged memory is freed. Therefore, the <strong>pixelData</strong> array stores each pixel over four array elements (R, G, B, A).</p><p>The <strong>TransformImage</strong> method is used to perform an imaging operation on the pixel data, such as convert to greyscale. The method specifies a <strong>Func</strong> parameter that’s used to perform a per-pixel operation. The <strong>Func</strong> is passed from the Xamarin.Forms PCL project into the method, and operates on each pixel component. At the moment the <strong>TransformImage</strong> method is hard-coded to place the result of the <strong>Func</strong> into each pixel component. This is purely for my own test purposes, for implementing a <strong>ConvertToGreyscale</strong> <strong>Func</strong> (see <a href="http://www.davidbritch.com/2015/11/accessing-image-pixel-data-in.html">previous blog post</a>). It can easily be modified to not duplicate the result of the <strong>Func</strong> across all four colour components.</p><p>The <strong>ToImage</strong> method is then used to place the transformed pixel data in a new <strong>UIImage</strong>, before performing some cleanup to allow managed memory to be reclaimed. Note that the <strong>ToImage</strong> method creates a 32 bit image. An overload could be provided to create a 8 bit image.</p><p>The <strong>Bitmap</strong> class can then be invoked as follows:</p><div id="scid:9D7513F9-C04C-4721-824A-2B34F0212519:bf80ef18-3b96-4c50-b244-7a4fc83e2216" class="wlWriterEditableSmartContent" style="float: none; padding-bottom: 0px; padding-top: 0px; padding-left: 0px; margin: 0px; display: inline; padding-right: 0px"><pre style=" width: 814px; height: 164px;background-color:White;overflow: hidden;"><div><!--<br /><br />Code highlighting produced by Actipro CodeHighlighter (freeware)<br />http://www.CodeHighlighter.com/<br /><br />--><span style="color: #008080;">1</span> <span style="color: #0000FF;">public</span><span style="color: #000000;"> Task</span><span style="color: #000000;">&lt;</span><span style="color: #000000;">Stream</span><span style="color: #000000;">&gt;</span><span style="color: #000000;"> TransformPhotoAsync (Func</span><span style="color: #000000;">&lt;</span><span style="color: #0000FF;">byte</span><span style="color: #000000;">, </span><span style="color: #0000FF;">byte</span><span style="color: #000000;">, </span><span style="color: #0000FF;">byte</span><span style="color: #000000;">, </span><span style="color: #0000FF;">double</span><span style="color: #000000;">&gt;</span><span style="color: #000000;"> pixelOperation)<br /></span><span style="color: #008080;">2</span> <span style="color: #000000;">{<br /></span><span style="color: #008080;">3</span> <span style="color: #000000;">    </span><span style="color: #0000FF;">return</span><span style="color: #000000;"> Task.Run (() </span><span style="color: #000000;">=&gt;</span><span style="color: #000000;"> {<br /></span><span style="color: #008080;">4</span> <span style="color: #000000;">        var bitmap </span><span style="color: #000000;">=</span><span style="color: #000000;"> </span><span style="color: #0000FF;">new</span><span style="color: #000000;"> Bitmap (image);<br /></span><span style="color: #008080;">5</span> <span style="color: #000000;">        bitmap.ToPixelArray ();<br /></span><span style="color: #008080;">6</span> <span style="color: #000000;">        bitmap.TransformImage (pixelOperation);<br /></span><span style="color: #008080;">7</span> <span style="color: #000000;">        </span><span style="color: #0000FF;">return</span><span style="color: #000000;"> bitmap.ToImage ().AsJPEG ().AsStream ();<br /></span><span style="color: #008080;">8</span> <span style="color: #000000;">    });<br /></span><span style="color: #008080;">9</span> <span style="color: #000000;">}</span></div></pre><!-- Code inserted with Steve Dunn's Windows Live Writer Code Formatter Plugin.  http://dunnhq.com --></div><p>A new <strong>Bitmap</strong> instance is created, with a <strong>UIImage</strong> instance being passed into the constructor. The <strong>UIImage</strong> is converted to an array of pixels, transformed by the <strong>pixelOperation</strong> <strong>Func</strong>, and then converted into a new <strong>UIImage</strong> before being returned for display by a Xamarin.Forms <strong>Image</strong> control. All of this work is wrapped in a <strong>Task.Run</strong> in order for it to be executed on a background thread.</p><h3>Summary</h3><p>This blog post has described how to access and manipulate pixel data in a Xamarin.Forms iOS project, by implementing the <strong>Bitmap</strong> class. The <strong>Bitmap</strong> class implements the <strong>IBitmap</strong> interface that’s provided by the Xamarin.Forms PCL project. My next blog post will explain the implementation of the <strong>IBitmap</strong> interface on Android.</p>  