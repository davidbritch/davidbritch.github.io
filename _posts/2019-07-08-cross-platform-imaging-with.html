---
title: Cross-platform imaging with Xamarin.Forms and SkiaSharp
date: '2019-07-08T10:59:00.001+01:00'
author: David Britch
tags:
- C#
- Xamarin
modified_time: '2019-07-08T11:06:57.911+01:00'
thumbnail: https://3.bp.blogspot.com/-CDZdXt8FuBM/XSMSqCh2sfI/AAAAAAAADAA/g4EMBkIeNzMdCmdfztUY7casZPQwARExACLcBGAs/s72-c/Simulator%2BScreen%2BShot%2B-%2BiPhone%2BX%2B-%2B2019-07-08%2Bat%2B09.41.09.png
blogger_id: tag:blogger.com,1999:blog-8265682915956744370.post-13053750234656495
blogger_orig_url: https://dbritch.blogspot.com/2019/07/cross-platform-imaging-with.html
---

<p>Back in the Xamarin.Forms 1.x days, I attempted to show the power of Xamarin.Forms development by writing a cross-platform imaging app. This was a mistake. While I produced a working cross-platform app, the majority of the code was platform code, joined together through <strong>DependencyService</strong> calls from a shared UI. If anything, it showed that it wasn’t easily possible to create a cross-platform imaging app with shared code. So it never saw the light of day.</p><p>I’d been thinking about this project recently, and while I knew that it’s possible to write cross-platform imaging apps with Xamarin.Forms and SkiaSharp, I wasn’t sure if it was advisable, from an execution speed point of view. In particular, I was worried about the execution speed of imaging algorithms on Android, especially when considering the resolution of photos taken with recent mobile devices. So I decided to write a proof of concept app to find out if Xamarin.Forms and SkiaSharp was a viable platform for writing cross-platform imaging apps.</p><h3>App requirements and assumptions</h3><p>When I talk about writing a cross-platform imaging app, I’m not particularly interested in calling platform APIs to resize images, crop images etc. I’m interested in accessing pixel data quickly, and being able to manipulate that data.</p><p>The core platforms I wanted to support were iOS and Android. UWP support would be a bonus, but I’d be happy to drop UWP support at the first sign of any issues.</p><p>The core functionality of the app is to load/display/save images, and manipulate the pixel values of the images as quickly as possible, with as much of this happening through shared code as possible. I wanted to support the common image file formats, but was only interested in supporting 32 bit images. The consequence of this is that when loading a colour image and converting it to greyscale, it would be saved back out as a 32 bit image, rather than an 8 bit image. </p><p>Note that the app is just a proof of concept app. Therefore, I wasn’t bothered about creating a slick UI. I just needed a functional UI. Similarly, I didn’t get hung up on architectural decisions. At one point I was going to implement each imaging algorithm using a plugin architecture, so the app would detect the algorithms and let the user choose them. But that was missing the point. It’s only a proof of concept. So it’s code-behind all the way, and the algorithms are hard-coded into the app.</p><h3>App overview</h3><p>The app was created in Xamarin.Forms and SkiaSharp, and the vast majority of the code is shared code. Platform code was required for choosing images on each platform, but that was about it. Image load/display/save/manipulation is handled with SkiaSharp shared code. Code for the sample app can be found on <a href="https://github.com/davidbritch/xamarin-forms/tree/master/Imaging" target="_blank">GitHub</a>.</p><p>As part of our SkiaSharp docs, we’ve covered how to <a href="https://docs.microsoft.com/en-gb/xamarin/xamarin-forms/user-interface/graphics/skiasharp/bitmaps/displaying" target="_blank">load and display an image using SkiaSharp</a>. We’ve also covered how to <a href="https://docs.microsoft.com/en-gb/xamarin/xamarin-forms/user-interface/graphics/skiasharp/bitmaps/saving" target="_blank">save images using SkiaSharp</a>. Our docs also explain how to <a href="https://docs.microsoft.com/en-gb/xamarin/xamarin-forms/app-fundamentals/dependency-service/photo-picker" target="_blank">write code to pick photos from the device’s photo library</a>. I won’t regurgitate these topics here. Instead, just know that the app uses the techniques covered in these docs. The only difference is that while I started by using the <strong>SKBitmap</strong> class, I soon moved to using the <strong>SKImage</strong> class, after discovering that Google have plans to deprecate <strong>SKBitmap</strong>. Here’s a screenshot of the app, that shows an image of my magilyzer, which I’ll use as a test image in this blog post:</p><div class="separator" style="clear: both; text-align: center;"><a href="https://3.bp.blogspot.com/-CDZdXt8FuBM/XSMSqCh2sfI/AAAAAAAADAA/g4EMBkIeNzMdCmdfztUY7casZPQwARExACLcBGAs/s1600/Simulator%2BScreen%2BShot%2B-%2BiPhone%2BX%2B-%2B2019-07-08%2Bat%2B09.41.09.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="https://3.bp.blogspot.com/-CDZdXt8FuBM/XSMSqCh2sfI/AAAAAAAADAA/g4EMBkIeNzMdCmdfztUY7casZPQwARExACLcBGAs/s320/Simulator%2BScreen%2BShot%2B-%2BiPhone%2BX%2B-%2B2019-07-08%2Bat%2B09.41.09.png" width="185" height="400" data-original-width="739" data-original-height="1600" /></a></div><p>We’ve also got docs on <a href="https://docs.microsoft.com/en-gb/xamarin/xamarin-forms/user-interface/graphics/skiasharp/bitmaps/pixel-bits" target="_blank">accessing pixel data in SkiaSharp</a>. SkiaSharp offers a number of different approaches for doing this, and understanding them is key to creating a performant app. In particular, take a look at the table in the <a href="https://docs.microsoft.com/en-gb/xamarin/xamarin-forms/user-interface/graphics/skiasharp/bitmaps/pixel-bits#comparing-the-techniques" target="_blank">Comparing the techniques</a> section of the doc. This table shows execution times in milliseconds for these different approaches. The TL;DR is that the fastest approach is to use the <strong>GetPixels</strong> method to return a pointer to the pixel data, deference the pointer whenever you want to read/write a pixel value, and use pointer arithmetic to move the pointer to process other pixels.</p><p>Using this approach requires knowledge of how pixel data is stored in memory on different platforms. On iOS and Android, each pixel is stored as four bytes in RGBA format, which is represented in SkiaSharp with the <strong>SKColorType.Rgba8888</strong> type. On UWP, each pixel is stored as four bytes in BGRA format, which is represented in SkiaSharp with the <strong>SKColorType.Bgra8888</strong> type. Initially, I coded my imaging algorithms for all three platforms, but I got sick of having to handle UWP’s special case, so at that point it was goodbye UWP! </p><h3>Basic algorithms</h3><p>As I mentioned earlier, the focus of the app isn’t on calling platform APIs to performing imaging operations. It’s on accessing pixel data and manipulating that data. If you want to know how to crop images with SkiaSharp, see <a href="https://docs.microsoft.com/en-gb/xamarin/xamarin-forms/user-interface/graphics/skiasharp/bitmaps/cropping" target="_blank">Cropping SkiaSharp bitmaps</a>. Similarly, SkiaSharp has functionality for resizing images. With all that said, the first imaging algorithm I always implement when getting to grips with a new platform is converting a colour image to greyscale, as it’s a simple algorithm. The following code example shows how I accomplished this in SkiaSharp:</p><div class="wlWriterSmartContent" id="scid:9D7513F9-C04C-4721-824A-2B34F0212519:3b87a686-97e3-4c5c-a694-3880f593c0a8" style="margin: 0px; padding: 0px; float: none; display: inline;"><pre style="width: 851px; height: 557px; overflow: visible; background-color: white;"><div><!--

Code highlighting produced by Actipro CodeHighlighter (freeware)
http://www.CodeHighlighter.com/

--><span style="color: rgb(0, 0, 255);">public</span><span style="color: rgb(0, 0, 0);"> </span><span style="color: rgb(0, 0, 255);">static</span><span style="color: rgb(0, 0, 0);"> </span><span style="color: rgb(0, 0, 255);">unsafe</span><span style="color: rgb(0, 0, 0);"> SKPixmap ToGreyscale(</span><span style="color: rgb(0, 0, 255);">this</span><span style="color: rgb(0, 0, 0);"> SKImage image)
{
    SKPixmap pixmap </span><span style="color: rgb(0, 0, 0);">=</span><span style="color: rgb(0, 0, 0);"> image.PeekPixels();
    </span><span style="color: rgb(0, 0, 255);">byte</span><span style="color: rgb(0, 0, 0);">*</span><span style="color: rgb(0, 0, 0);"> bmpPtr </span><span style="color: rgb(0, 0, 0);">=</span><span style="color: rgb(0, 0, 0);"> (</span><span style="color: rgb(0, 0, 255);">byte</span><span style="color: rgb(0, 0, 0);">*</span><span style="color: rgb(0, 0, 0);">)pixmap.GetPixels().ToPointer();
    </span><span style="color: rgb(0, 0, 255);">int</span><span style="color: rgb(0, 0, 0);"> width </span><span style="color: rgb(0, 0, 0);">=</span><span style="color: rgb(0, 0, 0);"> image.Width;
    </span><span style="color: rgb(0, 0, 255);">int</span><span style="color: rgb(0, 0, 0);"> height </span><span style="color: rgb(0, 0, 0);">=</span><span style="color: rgb(0, 0, 0);"> image.Height;
    </span><span style="color: rgb(0, 0, 255);">byte</span><span style="color: rgb(0, 0, 0);">*</span><span style="color: rgb(0, 0, 0);"> tempPtr;

    </span><span style="color: rgb(0, 0, 255);">for</span><span style="color: rgb(0, 0, 0);"> (</span><span style="color: rgb(0, 0, 255);">int</span><span style="color: rgb(0, 0, 0);"> row </span><span style="color: rgb(0, 0, 0);">=</span><span style="color: rgb(0, 0, 0);"> </span><span style="color: rgb(128, 0, 128);">0</span><span style="color: rgb(0, 0, 0);">; row </span><span style="color: rgb(0, 0, 0);">&lt;</span><span style="color: rgb(0, 0, 0);"> height; row</span><span style="color: rgb(0, 0, 0);">++</span><span style="color: rgb(0, 0, 0);">)
    {
        </span><span style="color: rgb(0, 0, 255);">for</span><span style="color: rgb(0, 0, 0);"> (</span><span style="color: rgb(0, 0, 255);">int</span><span style="color: rgb(0, 0, 0);"> col </span><span style="color: rgb(0, 0, 0);">=</span><span style="color: rgb(0, 0, 0);"> </span><span style="color: rgb(128, 0, 128);">0</span><span style="color: rgb(0, 0, 0);">; col </span><span style="color: rgb(0, 0, 0);">&lt;</span><span style="color: rgb(0, 0, 0);"> width; col</span><span style="color: rgb(0, 0, 0);">++</span><span style="color: rgb(0, 0, 0);">)
        {
            tempPtr </span><span style="color: rgb(0, 0, 0);">=</span><span style="color: rgb(0, 0, 0);"> bmpPtr;
            </span><span style="color: rgb(0, 0, 255);">byte</span><span style="color: rgb(0, 0, 0);"> red </span><span style="color: rgb(0, 0, 0);">=</span><span style="color: rgb(0, 0, 0);"> </span><span style="color: rgb(0, 0, 0);">*</span><span style="color: rgb(0, 0, 0);">bmpPtr</span><span style="color: rgb(0, 0, 0);">++</span><span style="color: rgb(0, 0, 0);">;
            </span><span style="color: rgb(0, 0, 255);">byte</span><span style="color: rgb(0, 0, 0);"> green </span><span style="color: rgb(0, 0, 0);">=</span><span style="color: rgb(0, 0, 0);"> </span><span style="color: rgb(0, 0, 0);">*</span><span style="color: rgb(0, 0, 0);">bmpPtr</span><span style="color: rgb(0, 0, 0);">++</span><span style="color: rgb(0, 0, 0);">;
            </span><span style="color: rgb(0, 0, 255);">byte</span><span style="color: rgb(0, 0, 0);"> blue </span><span style="color: rgb(0, 0, 0);">=</span><span style="color: rgb(0, 0, 0);"> </span><span style="color: rgb(0, 0, 0);">*</span><span style="color: rgb(0, 0, 0);">bmpPtr</span><span style="color: rgb(0, 0, 0);">++</span><span style="color: rgb(0, 0, 0);">;
            </span><span style="color: rgb(0, 0, 255);">byte</span><span style="color: rgb(0, 0, 0);"> alpha </span><span style="color: rgb(0, 0, 0);">=</span><span style="color: rgb(0, 0, 0);"> </span><span style="color: rgb(0, 0, 0);">*</span><span style="color: rgb(0, 0, 0);">bmpPtr</span><span style="color: rgb(0, 0, 0);">++</span><span style="color: rgb(0, 0, 0);">;

            </span><span style="color: rgb(0, 128, 0);">//</span><span style="color: rgb(0, 128, 0);"> Assuming SKColorType.Rgba8888 - used by iOS and Android
            </span><span style="color: rgb(0, 128, 0);">//</span><span style="color: rgb(0, 128, 0);"> (UWP uses SKColorType.Bgra8888)</span><span style="color: rgb(0, 128, 0);">
</span><span style="color: rgb(0, 0, 0);">            </span><span style="color: rgb(0, 0, 255);">byte</span><span style="color: rgb(0, 0, 0);"> result </span><span style="color: rgb(0, 0, 0);">=</span><span style="color: rgb(0, 0, 0);"> (</span><span style="color: rgb(0, 0, 255);">byte</span><span style="color: rgb(0, 0, 0);">)(</span><span style="color: rgb(128, 0, 128);">0.2126</span><span style="color: rgb(0, 0, 0);"> </span><span style="color: rgb(0, 0, 0);">*</span><span style="color: rgb(0, 0, 0);"> red </span><span style="color: rgb(0, 0, 0);">+</span><span style="color: rgb(0, 0, 0);"> </span><span style="color: rgb(128, 0, 128);">0.7152</span><span style="color: rgb(0, 0, 0);"> </span><span style="color: rgb(0, 0, 0);">*</span><span style="color: rgb(0, 0, 0);"> green </span><span style="color: rgb(0, 0, 0);">+</span><span style="color: rgb(0, 0, 0);"> </span><span style="color: rgb(128, 0, 128);">0.0722</span><span style="color: rgb(0, 0, 0);"> </span><span style="color: rgb(0, 0, 0);">*</span><span style="color: rgb(0, 0, 0);"> blue);

            bmpPtr </span><span style="color: rgb(0, 0, 0);">=</span><span style="color: rgb(0, 0, 0);"> tempPtr;
            </span><span style="color: rgb(0, 0, 0);">*</span><span style="color: rgb(0, 0, 0);">bmpPtr</span><span style="color: rgb(0, 0, 0);">++</span><span style="color: rgb(0, 0, 0);"> </span><span style="color: rgb(0, 0, 0);">=</span><span style="color: rgb(0, 0, 0);"> result; </span><span style="color: rgb(0, 128, 0);">//</span><span style="color: rgb(0, 128, 0);"> red</span><span style="color: rgb(0, 128, 0);">
</span><span style="color: rgb(0, 0, 0);">            </span><span style="color: rgb(0, 0, 0);">*</span><span style="color: rgb(0, 0, 0);">bmpPtr</span><span style="color: rgb(0, 0, 0);">++</span><span style="color: rgb(0, 0, 0);"> </span><span style="color: rgb(0, 0, 0);">=</span><span style="color: rgb(0, 0, 0);"> result; </span><span style="color: rgb(0, 128, 0);">//</span><span style="color: rgb(0, 128, 0);"> green</span><span style="color: rgb(0, 128, 0);">
</span><span style="color: rgb(0, 0, 0);">            </span><span style="color: rgb(0, 0, 0);">*</span><span style="color: rgb(0, 0, 0);">bmpPtr</span><span style="color: rgb(0, 0, 0);">++</span><span style="color: rgb(0, 0, 0);"> </span><span style="color: rgb(0, 0, 0);">=</span><span style="color: rgb(0, 0, 0);"> result; </span><span style="color: rgb(0, 128, 0);">//</span><span style="color: rgb(0, 128, 0);"> blue</span><span style="color: rgb(0, 128, 0);">
</span><span style="color: rgb(0, 0, 0);">            </span><span style="color: rgb(0, 0, 0);">*</span><span style="color: rgb(0, 0, 0);">bmpPtr</span><span style="color: rgb(0, 0, 0);">++</span><span style="color: rgb(0, 0, 0);"> </span><span style="color: rgb(0, 0, 0);">=</span><span style="color: rgb(0, 0, 0);"> alpha;  </span><span style="color: rgb(0, 128, 0);">//</span><span style="color: rgb(0, 128, 0);"> alpha</span><span style="color: rgb(0, 128, 0);">
</span><span style="color: rgb(0, 0, 0);">        }
    }
    </span><span style="color: rgb(0, 0, 255);">return</span><span style="color: rgb(0, 0, 0);"> pixmap;
}</span></div></pre><!-- Code inserted with Steve Dunn's Windows Live Writer Code Formatter Plugin.  http://dunnhq.com --></div><p>This method converts a colour image to greyscale by retrieving a pointer to the start of the pixel data, and then retrieving the R, G, B, and A components of each pixel by deferencing the pointer, and then incrementing it’s address. The greyscale pixel value is obtained by multiplying the R value by 0.2126, multiplying the G value by 0.7152, multiplying the B value by 0.0722, and then summing the results. Note that the input to this method is an image in RGBA8888 format, and the output is an image in RGBA8888 format, despite being a greyscale image. Therefore the R, G, and B components of each pixel are all set to the same value. The following screenshot shows the test image converted to greyscale, on iOS:</p><div class="separator" style="clear: both; text-align: center;"><a href="https://2.bp.blogspot.com/-QcP9qWqYOjo/XSMTb_RmnsI/AAAAAAAADAg/Nao3tONbLScjioMR3IalpzSTq8lNNE0JQCLcBGAs/s1600/Simulator%2BScreen%2BShot%2B-%2BiPhone%2BX%2B-%2B2019-07-08%2Bat%2B09.41.14.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="https://2.bp.blogspot.com/-QcP9qWqYOjo/XSMTb_RmnsI/AAAAAAAADAg/Nao3tONbLScjioMR3IalpzSTq8lNNE0JQCLcBGAs/s400/Simulator%2BScreen%2BShot%2B-%2BiPhone%2BX%2B-%2B2019-07-08%2Bat%2B09.41.14.png" width="185" height="400" data-original-width="739" data-original-height="1600" /></a></div><p>As an example of colour processing, I implemented an algorithm for converting an image to sepia, which is shown in the following example:</p><div class="wlWriterSmartContent" id="scid:9D7513F9-C04C-4721-824A-2B34F0212519:a1ee54f1-1136-4615-b960-ae22dc3578ef" style="margin: 0px; padding: 0px; float: none; display: inline;"><pre style="width: 851px; height: 557px; overflow: visible; background-color: white;"><div><!--

Code highlighting produced by Actipro CodeHighlighter (freeware)
http://www.CodeHighlighter.com/

--><span style="color: rgb(0, 0, 255);">public</span><span style="color: rgb(0, 0, 0);"> </span><span style="color: rgb(0, 0, 255);">static</span><span style="color: rgb(0, 0, 0);"> </span><span style="color: rgb(0, 0, 255);">unsafe</span><span style="color: rgb(0, 0, 0);"> SKPixmap ToSepia(</span><span style="color: rgb(0, 0, 255);">this</span><span style="color: rgb(0, 0, 0);"> SKImage image)
{
    SKPixmap pixmap </span><span style="color: rgb(0, 0, 0);">=</span><span style="color: rgb(0, 0, 0);"> image.PeekPixels();
    </span><span style="color: rgb(0, 0, 255);">byte</span><span style="color: rgb(0, 0, 0);">*</span><span style="color: rgb(0, 0, 0);"> bmpPtr </span><span style="color: rgb(0, 0, 0);">=</span><span style="color: rgb(0, 0, 0);"> (</span><span style="color: rgb(0, 0, 255);">byte</span><span style="color: rgb(0, 0, 0);">*</span><span style="color: rgb(0, 0, 0);">)pixmap.GetPixels().ToPointer();
    </span><span style="color: rgb(0, 0, 255);">int</span><span style="color: rgb(0, 0, 0);"> width </span><span style="color: rgb(0, 0, 0);">=</span><span style="color: rgb(0, 0, 0);"> image.Width;
    </span><span style="color: rgb(0, 0, 255);">int</span><span style="color: rgb(0, 0, 0);"> height </span><span style="color: rgb(0, 0, 0);">=</span><span style="color: rgb(0, 0, 0);"> image.Height;
    </span><span style="color: rgb(0, 0, 255);">byte</span><span style="color: rgb(0, 0, 0);">*</span><span style="color: rgb(0, 0, 0);"> tempPtr;

    </span><span style="color: rgb(0, 0, 255);">for</span><span style="color: rgb(0, 0, 0);"> (</span><span style="color: rgb(0, 0, 255);">int</span><span style="color: rgb(0, 0, 0);"> row </span><span style="color: rgb(0, 0, 0);">=</span><span style="color: rgb(0, 0, 0);"> </span><span style="color: rgb(128, 0, 128);">0</span><span style="color: rgb(0, 0, 0);">; row </span><span style="color: rgb(0, 0, 0);">&lt;</span><span style="color: rgb(0, 0, 0);"> height; row</span><span style="color: rgb(0, 0, 0);">++</span><span style="color: rgb(0, 0, 0);">)
    {
        </span><span style="color: rgb(0, 0, 255);">for</span><span style="color: rgb(0, 0, 0);"> (</span><span style="color: rgb(0, 0, 255);">int</span><span style="color: rgb(0, 0, 0);"> col </span><span style="color: rgb(0, 0, 0);">=</span><span style="color: rgb(0, 0, 0);"> </span><span style="color: rgb(128, 0, 128);">0</span><span style="color: rgb(0, 0, 0);">; col </span><span style="color: rgb(0, 0, 0);">&lt;</span><span style="color: rgb(0, 0, 0);"> width; col</span><span style="color: rgb(0, 0, 0);">++</span><span style="color: rgb(0, 0, 0);">)
        {
            tempPtr </span><span style="color: rgb(0, 0, 0);">=</span><span style="color: rgb(0, 0, 0);"> bmpPtr;
            </span><span style="color: rgb(0, 0, 255);">byte</span><span style="color: rgb(0, 0, 0);"> red </span><span style="color: rgb(0, 0, 0);">=</span><span style="color: rgb(0, 0, 0);"> </span><span style="color: rgb(0, 0, 0);">*</span><span style="color: rgb(0, 0, 0);">bmpPtr</span><span style="color: rgb(0, 0, 0);">++</span><span style="color: rgb(0, 0, 0);">;
            </span><span style="color: rgb(0, 0, 255);">byte</span><span style="color: rgb(0, 0, 0);"> green </span><span style="color: rgb(0, 0, 0);">=</span><span style="color: rgb(0, 0, 0);"> </span><span style="color: rgb(0, 0, 0);">*</span><span style="color: rgb(0, 0, 0);">bmpPtr</span><span style="color: rgb(0, 0, 0);">++</span><span style="color: rgb(0, 0, 0);">;
            </span><span style="color: rgb(0, 0, 255);">byte</span><span style="color: rgb(0, 0, 0);"> blue </span><span style="color: rgb(0, 0, 0);">=</span><span style="color: rgb(0, 0, 0);"> </span><span style="color: rgb(0, 0, 0);">*</span><span style="color: rgb(0, 0, 0);">bmpPtr</span><span style="color: rgb(0, 0, 0);">++</span><span style="color: rgb(0, 0, 0);">;
            </span><span style="color: rgb(0, 0, 255);">byte</span><span style="color: rgb(0, 0, 0);"> alpha </span><span style="color: rgb(0, 0, 0);">=</span><span style="color: rgb(0, 0, 0);"> </span><span style="color: rgb(0, 0, 0);">*</span><span style="color: rgb(0, 0, 0);">bmpPtr</span><span style="color: rgb(0, 0, 0);">++</span><span style="color: rgb(0, 0, 0);">;

            </span><span style="color: rgb(0, 128, 0);">//</span><span style="color: rgb(0, 128, 0);"> Assuming SKColorType.Rgba8888 - used by iOS and Android
            </span><span style="color: rgb(0, 128, 0);">//</span><span style="color: rgb(0, 128, 0);"> (UWP uses SKColorType.Bgra8888)</span><span style="color: rgb(0, 128, 0);">
</span><span style="color: rgb(0, 0, 0);">            </span><span style="color: rgb(0, 0, 255);">byte</span><span style="color: rgb(0, 0, 0);"> intensity </span><span style="color: rgb(0, 0, 0);">=</span><span style="color: rgb(0, 0, 0);"> (</span><span style="color: rgb(0, 0, 255);">byte</span><span style="color: rgb(0, 0, 0);">)(</span><span style="color: rgb(128, 0, 128);">0.299</span><span style="color: rgb(0, 0, 0);"> </span><span style="color: rgb(0, 0, 0);">*</span><span style="color: rgb(0, 0, 0);"> red </span><span style="color: rgb(0, 0, 0);">+</span><span style="color: rgb(0, 0, 0);"> </span><span style="color: rgb(128, 0, 128);">0.587</span><span style="color: rgb(0, 0, 0);"> </span><span style="color: rgb(0, 0, 0);">*</span><span style="color: rgb(0, 0, 0);"> green </span><span style="color: rgb(0, 0, 0);">+</span><span style="color: rgb(0, 0, 0);"> </span><span style="color: rgb(128, 0, 128);">0.114</span><span style="color: rgb(0, 0, 0);"> </span><span style="color: rgb(0, 0, 0);">*</span><span style="color: rgb(0, 0, 0);"> blue);

            bmpPtr </span><span style="color: rgb(0, 0, 0);">=</span><span style="color: rgb(0, 0, 0);"> tempPtr;
            </span><span style="color: rgb(0, 0, 0);">*</span><span style="color: rgb(0, 0, 0);">bmpPtr</span><span style="color: rgb(0, 0, 0);">++</span><span style="color: rgb(0, 0, 0);"> </span><span style="color: rgb(0, 0, 0);">=</span><span style="color: rgb(0, 0, 0);"> (</span><span style="color: rgb(0, 0, 255);">byte</span><span style="color: rgb(0, 0, 0);">)((intensity </span><span style="color: rgb(0, 0, 0);">&gt;</span><span style="color: rgb(0, 0, 0);"> </span><span style="color: rgb(128, 0, 128);">206</span><span style="color: rgb(0, 0, 0);">) </span><span style="color: rgb(0, 0, 0);">?</span><span style="color: rgb(0, 0, 0);"> </span><span style="color: rgb(128, 0, 128);">255</span><span style="color: rgb(0, 0, 0);"> : intensity </span><span style="color: rgb(0, 0, 0);">+</span><span style="color: rgb(0, 0, 0);"> </span><span style="color: rgb(128, 0, 128);">49</span><span style="color: rgb(0, 0, 0);">); </span><span style="color: rgb(0, 128, 0);">//</span><span style="color: rgb(0, 128, 0);"> red</span><span style="color: rgb(0, 128, 0);">
</span><span style="color: rgb(0, 0, 0);">            </span><span style="color: rgb(0, 0, 0);">*</span><span style="color: rgb(0, 0, 0);">bmpPtr</span><span style="color: rgb(0, 0, 0);">++</span><span style="color: rgb(0, 0, 0);"> </span><span style="color: rgb(0, 0, 0);">=</span><span style="color: rgb(0, 0, 0);"> (</span><span style="color: rgb(0, 0, 255);">byte</span><span style="color: rgb(0, 0, 0);">)((intensity </span><span style="color: rgb(0, 0, 0);">&lt;</span><span style="color: rgb(0, 0, 0);"> </span><span style="color: rgb(128, 0, 128);">14</span><span style="color: rgb(0, 0, 0);">) </span><span style="color: rgb(0, 0, 0);">?</span><span style="color: rgb(0, 0, 0);"> </span><span style="color: rgb(128, 0, 128);">0</span><span style="color: rgb(0, 0, 0);"> : intensity </span><span style="color: rgb(0, 0, 0);">-</span><span style="color: rgb(0, 0, 0);"> </span><span style="color: rgb(128, 0, 128);">14</span><span style="color: rgb(0, 0, 0);">);    </span><span style="color: rgb(0, 128, 0);">//</span><span style="color: rgb(0, 128, 0);"> green</span><span style="color: rgb(0, 128, 0);">
</span><span style="color: rgb(0, 0, 0);">            </span><span style="color: rgb(0, 0, 0);">*</span><span style="color: rgb(0, 0, 0);">bmpPtr</span><span style="color: rgb(0, 0, 0);">++</span><span style="color: rgb(0, 0, 0);"> </span><span style="color: rgb(0, 0, 0);">=</span><span style="color: rgb(0, 0, 0);"> (</span><span style="color: rgb(0, 0, 255);">byte</span><span style="color: rgb(0, 0, 0);">)((intensity </span><span style="color: rgb(0, 0, 0);">&lt;</span><span style="color: rgb(0, 0, 0);"> </span><span style="color: rgb(128, 0, 128);">56</span><span style="color: rgb(0, 0, 0);">) </span><span style="color: rgb(0, 0, 0);">?</span><span style="color: rgb(0, 0, 0);"> </span><span style="color: rgb(128, 0, 128);">0</span><span style="color: rgb(0, 0, 0);"> : intensity </span><span style="color: rgb(0, 0, 0);">-</span><span style="color: rgb(0, 0, 0);"> </span><span style="color: rgb(128, 0, 128);">56</span><span style="color: rgb(0, 0, 0);">);    </span><span style="color: rgb(0, 128, 0);">//</span><span style="color: rgb(0, 128, 0);"> blue</span><span style="color: rgb(0, 128, 0);">
</span><span style="color: rgb(0, 0, 0);">            </span><span style="color: rgb(0, 0, 0);">*</span><span style="color: rgb(0, 0, 0);">bmpPtr</span><span style="color: rgb(0, 0, 0);">++</span><span style="color: rgb(0, 0, 0);"> </span><span style="color: rgb(0, 0, 0);">=</span><span style="color: rgb(0, 0, 0);"> alpha;  </span><span style="color: rgb(0, 128, 0);">//</span><span style="color: rgb(0, 128, 0);"> alpha                    </span><span style="color: rgb(0, 128, 0);">
</span><span style="color: rgb(0, 0, 0);">        }
    }
    </span><span style="color: rgb(0, 0, 255);">return</span><span style="color: rgb(0, 0, 0);"> pixmap;
}</span></div></pre><!-- Code inserted with Steve Dunn's Windows Live Writer Code Formatter Plugin.  http://dunnhq.com --></div><p>This method first derives an intensity value for the pixel (essentially a greyscale representation of the pixel), based on its R, G, and B components, and then sets the R, G, and B components based on this intensity value. The following screenshot shows the test image converted to sepia, on iOS:</p><div class="separator" style="clear: both; text-align: center;"><a href="https://4.bp.blogspot.com/-wWbMuDUFkNI/XSMTKKqe32I/AAAAAAAADAU/RbbXMj9TVgsJgpL6oJ0U38vnKKCCwDclwCLcBGAs/s1600/Simulator%2BScreen%2BShot%2B-%2BiPhone%2BX%2B-%2B2019-07-08%2Bat%2B09.41.51.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="https://4.bp.blogspot.com/-wWbMuDUFkNI/XSMTKKqe32I/AAAAAAAADAU/RbbXMj9TVgsJgpL6oJ0U38vnKKCCwDclwCLcBGAs/s320/Simulator%2BScreen%2BShot%2B-%2BiPhone%2BX%2B-%2B2019-07-08%2Bat%2B09.41.51.png" width="185" height="400" data-original-width="739" data-original-height="1600" /></a></div><p>I also implemented Otsu’s thresholding algorithm, as an example of binarisation. This algorithm typically derives the threshold for an image by minimizing intra-class variance. However, the implementation I’ve used derives the threshold by maximising inter-class variance, which is equivalent. The threshold is then used to separate pixels into foreground and background classes. For more information about this algorithm, see <a href="https://en.wikipedia.org/wiki/Otsu%27s_method" target="_blank">Otsu’s method</a>. The code for the algorithm can be found on <a href="https://github.com/davidbritch/xamarin-forms/tree/master/Imaging" target="_blank">GitHub</a>. The following screenshot shows the test image thresholded with this algorithm, on iOS:</p><div class="separator" style="clear: both; text-align: center;"><a href="https://1.bp.blogspot.com/-xGnxCFFqb3M/XSMS9wV2mWI/AAAAAAAADAQ/d5VFfRHKHiQHmp5VcgvWbCD0UjxDETk8ACLcBGAs/s1600/Simulator%2BScreen%2BShot%2B-%2BiPhone%2BX%2B-%2B2019-07-08%2Bat%2B09.41.24.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="https://1.bp.blogspot.com/-xGnxCFFqb3M/XSMS9wV2mWI/AAAAAAAADAQ/d5VFfRHKHiQHmp5VcgvWbCD0UjxDETk8ACLcBGAs/s320/Simulator%2BScreen%2BShot%2B-%2BiPhone%2BX%2B-%2B2019-07-08%2Bat%2B09.41.24.png" width="185" height="400" data-original-width="739" data-original-height="1600" /></a></div><h3>Wrapping up</h3><p>The question I set out to answer is as follows: is the combination of Xamarin.Forms and a SkiaSharp a viable platform for writing cross-platform imaging apps? My main criteria for answering this question are:</p><ol><li>Can most of the app be written in shared code? <br />
<li>Can imaging algorithms be implemented so that they have a fast execution speed, particularly on Android?</li></ol><p>The answer to both questions, at this stage, is yes. In particular, I was impressed with the execution speed of the algorithms on both platforms (even Android!). I was particularly impressed when considering the size of the source image (4032x3024). The reason I say at this stage is because the algorithms I’ve implemented are quite basic. They don’t really do any heavy processing. Therefore, in my next blog post I’ll look at performing convolution operations, which up the amount of processing performed on an image.</p><p>The sample this code comes from can be found on <a href="https://github.com/davidbritch/xamarin-forms/tree/master/Imaging" target="_blank">GitHub</a>.</p>